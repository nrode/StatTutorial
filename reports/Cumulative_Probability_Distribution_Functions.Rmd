---
title: "Compute probability and cumulative distribution functions"
author: "Nicolas Rode"
date: "`r format(Sys.Date(), '%d-%B-%Y')`"
output: 
  html_document:
    theme: "journal"
    toc: true
    toc_depth: 3
    number_sections: true
    toc_float:
      collapsed: false
      smooth_scroll: false
editor_options: 
  chunk_output_type: console
---

```{r }
library(ggplot2)
library(dplyr)
library(ggpubr)
```


# Poisson distribution 
Used to model count data where the events occur randomly and independently at a constant rate
Range: {0, 1, 2, 3, ...}
Examples: Number of accidents in a day, number of calls received by a customer service center
Probability mass function: P(X=xi) = (exp^(-λ) λ^xi) / xi!
Graph: distribution skewed to the right
Assumptions: The mean and variance of the distribution are equal
Equations: E(X) = Var(X) = λ 

## PDF
### Compute PDF
```{r}

## Define function
compute_pdf <- function(lambda, xi){
  (exp(-lambda)*lambda^xi) / factorial(xi)
}

## Compute the probability of observing zero larvae
compute_pdf(lambda=1, xi=0)
```

### Plot PDF
```{r}
p <- ggplot(data.frame(x = 0:20), aes(x)) +
    stat_function(geom = "point", n = 21, fun = dpois, args = list(lambda = 1), color = "orange")+
    stat_function(geom = "point", n = 21, fun = dpois, args = list(lambda = 4), color = "purple")+
    stat_function(geom = "point", n = 21, fun = dpois, args = list(lambda = 10), color = "lightblue")+
    annotate("text", x=15, y=0.35, label= "lambda == 1", parse = TRUE, color = "orange")+
    annotate("text", x=15, y=0.3, label= "lambda == 4", parse = TRUE, color = "purple")+
    annotate("text", x=15, y=0.25, label= "lambda == 10", parse = TRUE, color = "lightblue")+ 
  xlab(bquote(x[i]))+ 
  ylab(bquote(P(X==x[i])))
p

p1 <- p +
  stat_function(geom = "area", aes(x), n = 4, fun = dpois, args = list(lambda = 1), xlim = c(0, 3), fill = "orange", alpha = 0.5)
p1

p2 <- p1 +
  stat_function(geom = "area", aes(x), n = 4, fun = dpois, args = list(lambda = 4), xlim = c(0, 3), fill = "purple", alpha = 0.5)
p2
p3 <- p2 +
  stat_function(geom = "area", aes(x), n = 4, fun = dpois, args = list(lambda = 10), xlim = c(0, 3), fill = "lightblue", alpha = 0.5)
p3

```
## CDF
```{r}

p4 <- ggplot(data.frame(x = 0:20), aes(x)) +
    stat_function(geom = "point", n = 21, fun = ppois, args = list(lambda = 1), color = "orange")+
    stat_function(geom = "point", n = 21, fun = ppois, args = list(lambda = 4), color = "purple")+
    stat_function(geom = "point", n = 21, fun = ppois, args = list(lambda = 10), color = "lightblue")+
    annotate("text", x=15, y=0.75, label= "lambda == 1", parse = TRUE, color = "orange")+
    annotate("text", x=15, y=0.7, label= "lambda == 4", parse = TRUE, color = "purple")+
    annotate("text", x=15, y=0.65, label= "lambda == 10", parse = TRUE, color = "lightblue")+ 
  xlab(bquote(x[i]))+ 
  ylab(bquote(P(X<=x[i])))
p4

ggarrange(p, p4, ncol = 2, nrow = 1)
```
## Simulations
### Plot distribution
```{r}
# Simulate data with rpois
set.seed(123)  # for reproducibility
data <- data.frame(y=rpois(n = 5, lambda = 1))

# If the minimum value is zero or a positive integer, then the variable might be a count variable.
min(data)  # check minimum value

## Check probability of each type of event
table(data)  # count occurrences of each value
prop.table(table(data))  # calculate proportion of occurrences


## Plot observed distribution and expected PDF
p <- data %>%
  ggplot2::ggplot(aes(y)) + 
  geom_histogram(aes(y = after_stat(count / sum(count))), fill = "orange", alpha = 0.2, binwidth = 0.25)+
  labs(title = "Probability Mass Function", x = "Value taken by X", y = "Proportion of events") + 
  stat_function(geom = "point", n = 4, fun = dpois, args = list(lambda = 1), color = "orange")
p

# check mean and variance are equal or not
mean(data$y)  # calculate mean
var(data$y)  # calculate variance
```

### Compute ML by hand
```{r}

dpois(x=0, lambda = 1, log=TRUE)

## Compute the product
prod(dpois(data$y, lambda = 0.5))

## Possible values of lambda
possible.lambda <- seq(0, 3, by=0.1)

## Write function
compute_prob <- function(lambda, sim.data=data){
  prod(dpois(sim.data$y, lambda = lambda))
}

compute_prob(lambda=1, sim.data=data)
compute_prob(lambda=1.6, sim.data=data)
compute_prob(lambda=2, sim.data=data)

## Apply function over each possible value
sapply(possible.lambda, compute_prob)

## Plot likelihood profile
plot(x=possible.lambda, y=sapply(possible.lambda, compute_prob))
abline(v=mean(data$y), col='red')
```

### Compute MLE using the optim function in R
```{r}
## Write the  the log-likelihood function
loglik <- function(sim.data=data$y, lambda) {
sumlogprob <- sum(dpois(sim.data, lambda=lambda, log = TRUE))
return(sumlogprob)}

## Example of values
loglik(lambda=1, sim.data=data$y)
loglik(lambda=1.6, sim.data=data$y)
loglik(lambda=2, sim.data=data$y)

## Based on Bloker 2008 p173 (use control option to perform maximization)
MLest <- optim(fn = loglik, par=c(lambda = 1), sim.data=data$y,  method = "BFGS", control = list(fnscale = -1))
MLest$par
MLest$value

```

### Compute MLE using the glm function in R
```{r}
# fit into model for poisson 
m0 <- glm(y ~ 1, family = poisson, data=data)  # fit Poisson regression model
summary(m0)  # display model summary
logLik(m0)
coef(m0)
exp(coef(m0))

data$obs <- as.factor(1:nrow(data))
m1 <- glm(y ~ obs, family = poisson, data=data) 
summary(m1)  # display model summary
logLik(m1)
coef(m1)
exp(coef(m0))

dev0 <- -2 *logLik(m0)
dev1 <- -2 *logLik(m1)

dev0-dev1
```


# Normal distribution 
Used to model continuous variables that follow a bell-shaped curve.
Range: (-∞, +∞)
Examples: Heights of individuals, weights of objects, errors in measurements
Density function: <p>f(x) = \frac{1}{\sigma\sqrt{2\pi}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}</p>
Graph: Bell-shaped curve
Assumptions: Data is normally distributed and has equal variance
Equations: E(X) = µ, Var(X) = σ²

# Binomial distribution 
Used to model the probability of a binary outcome (success or failure) in a fixed number of trials
Range: {0, 1, 2, ..., n}
Examples: Flipping a coin a certain number of times and counting the number of heads, the number of defective items in a sample of products
Probability mass function: P(X=k) = (n choose k) p^k (1-p)^(n-k)
Graph: Symmetrical distribution
Assumptions: Trials are independent and have the same probability of success
Equations: E(X) = np, Var(X) = np(1-p)
